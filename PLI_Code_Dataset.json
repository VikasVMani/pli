[
    {
        "instruction": "write a code to compute the largest of 3 float binary numbers x,y and z",
        "input": "",
        "output": "/***************************************/\n/* This program computes the largest of three */\n /* FLOAT BINARY numbers x, y, and z*/\n/******************************************\ntest:\nprocedure options (main);\ndeclare\n (a,b,c) float binary;\nput list ('Type Three Numbers: ');\nget list (a,b,c);\nput list ('The Largest Value is',max3(a,b,c));\n/* this procedure computes the largest of x,y, and z*/\n max3: procedure (x,y,z)\nreturns(float binary);\ndeclare\n(x,y,z,max) float binary;\nif x>y then\nif x >z then\nmax=x;\nelse\nmax = z;\nelse\nif y>z then\nmax = y;\nelse\nmax=z;\nreturn(max);\nend max3;\nend test;"
    },
    {
        "instruction": "write a code for compilation of demo using $N switch",
        "input": "",
        "output": "\ndemo:\n    procedure options(main);\n    declare\n        name character(20) varying;\n    put skip(2) list('PLEASE ENTER YOUR FIRST NAME: ');\n    get list(name);\n    put skip(2) list('HELLO '::name::', WELCOME TO PL/I'):\ndemo;\n"
    },
    {
        "instruction": "write a polynomial evalution program",
        "input": "",
        "output": "\n/**************************************************/\n/* This program evaluates a polynomial expression */\n/* using FLOAT BINARY data. */\n/**************************************************/\nfltpoly:\n    procedure options(main);\n    \n    %replace \n        true by '1'b;\n    declare\n        (x,y,z) float binary(24);\n    do while(true);\n        put skip(2) list('Type x,y,z: ');\n        get list(x,y,z);\n        \n        if x=0 & y=0 & z=0 then\n            stop;\n        put skip list('    2');\n        put skip list('    x+2y+z=',P(x,y,z));\n        end;\n        P:\n            procedure (x,y,z) returns (float binary(24));\n            declare\n                (x,y,z) float binary;\n            return(x*x+2*y+z);\n        end P;\nend fltpoly;\n\n"
    },
    {
        "instruction": "write a polynomial evalution program using fixed decimal",
        "input": "",
        "output": "\n/**********************************************/\n/* This program evaluates a polynomial expression using FIXED DECIMAL data.*/\n/**********************************************/\n\ndecpoly:\n    procedure options (main);\n    %replace\n        true by '1'b;\n    declare\n        (x,y,z) fixed decimal (15,4);\n    do while (true);\n        put skip(2) list('Type x,y,z: '); \n        get list(x,y,z);\n        if x=0 & y=0 & z=0 then\n            stop;\n        put skip list('    2');\n        put skip list('    x+2y+z=',P(x,y,z));\n        end;\n        P:\n            procedure (x,y,z) returns (fixed decimal (15,4));\n            declare\n                (x,y,z) fixed decimal(15,4);\n            return(x*x+2*y+z);\n        end P;\nend decpoly\n"
    },
    {
        "instruction": "can you write a sample code for the optimist program?",
        "input": "",
        "output": "/**************************************************/\n/* This program demonstrates PL/I character string*/\n/* processing by turning a negative sentence into a */\n/* positive one. \t\t\t\t\t\t\t\t*/\n/***********************************************************/\noptimist:\nprocedure options (main);\n%replace\n\ttrue by '1'b, \n\tfalse by '0'b, \n\tnwords by 5;\ndeclare\n\tnegative (1:nwords) character (8) varying static initial \n\t\t(' never',' none', ' nothing',' not', ' no'),\n\tPositive (1:nwords) character(10) varying static initial\n\t\t(' always', ' all',' something',' ''' some'), \n\tupper character (28) static initial\n\t\t('ABCDEFGHIJKLMNOPORSTUVWXYZ, ') ,\n\tlower character (28) static initial\n\t\t('abodefghijklmnoparstuvwxyz. '),\n\tsent character (254) varying,\n\tword character (32) varying, \n\t(I,j) fixed;\n\ndo while(true);\nput skip list('What’s up? ');\nsent = '\t';\ndo while\n(substr(sent,length(sent)) ^= ‘.’);\nget list (word) ;\nsent = sent !! ‘ ’ !! word;\nend;\nsent = translate(sent, lower,upper) i\nif verify(sent, lower) ^= 0 then\n\tsent = ‘ that’ is an interesting idea,';\ndo i = 1 to nwords;\nj= indextsent negative (il);\nif j^= 0 then\n\tsent = substr(sent,1,j-1) !!\npositive (i) !! \nsubstr(sent,j+length (negative (i)));\nend;\nput list('Actually,'!!sent);\nput skip;\nend;\nend optimisti;\n"
    },
    {
        "instruction": "What is FSCAN program in PL/I?",
        "input": "",
        "output": "FSCAN demonstrates the embedded subroutine called GNT, Get Next Token, which parses an input line into separate items called tokens. Once you test GNT, you can extract it from this program and put it into a production program where required."
    },
    {
        "instruction": "Write the FSCAN program in PL/I.",
        "input": "",
        "output": "/**************************************************/\n/* This program tests the procedure called GNT, a */\n/* free-field scanner (parser) that reads a line  */\n/* of input and breaks it into individual parts.  */\n/**************************************************/\nfscan:\n  procedure options(Main);\n  5replace\n    true by '1'b;\n  declare \n    token character(80) varying static initial('');\n\n  GNT:\n    procedure;\n    declare\n      i fixed;\n      line character(80) varying static initial('');\n\n    line = substr(line,length(token)+1);\n    do while(true);\n      if line = '' then\n        get edit(line) (a);\n\n      i = verify(line, ' ');\n      if i = 0 then\n        line = '';\n      else\n      do;\n        line = substr(line, i);\n        i = verify(line, '0123456789.');\n        if i = 0 then\n          token = line;\n        else\n        if i = 1 then\n          token = substr(line, 1, 1);\n        else\n          token = substr(line, 1, i-1);\n        return;\n      end;\n    end;\n  end GNT;\n\n  do while(true);\n    call GNT;\n    put edit('''' !! token !! '''') (x(1), a);\n  end;\nend fscan;\nThe FSCAN program has three parts. The first part, lines 10 to 12, defines the global data area called token, used by the GNT procedure. The second part, lines 14 to 42, is the GNT procedure itself. The third part is the DO-group between lines 44 and 47 that performs the test of the GNT function procedure."
    },
    {
        "instruction": "Write a PL/I program to read a sentence and reverse it.",
        "input": "",
        "output": "/**************************************************/\n/* This program reads a sentence and reverses it. */\n/**************************************************/\nreverse:\n  procedure options(Main);\n  declare\n    sentence pointer,\n    1 wordnode based (sentence),\n      2 word character(35) varying,\n      2 next pointer;\n\n  do while('1'b);\n    call read_it();\n    if sentence = null then\n      stop;\n    call write_it();\n  end;\n\n  read_it:\n    procedure;\n    declare\n      newword character(35) varying,\n      newnode pointer;\n\n    sentence = null;\n    put skip list('What''s up?');\n    do while('1'b);\n      get list(newword);\n      if newword = '.' then\n        return;\n      allocate wordnode set(newnode);\n      newnode->next = sentence;\n      sentence = newword;\n      word = newnode;\n    end;\n  end read_it;\n\n  write_it:\n    procedure;\n    declare\n      p pointer;\n\n    put skip list('Actually, ');\n    do while (sentence ^= null);\n      put list(word);\n      p = sentence;\n      sentence = next;\n      free p->wordnode;\n    end;\n    put list('.');\n    put skip;\n  end write_it;\n\nend reverse;"
    },
    {
        "instruction": "Write a NETWORK program in PL/I which consist of all the procedures like setup, connect, find, print_all, print_paths, print_route, shortest_distance and free all.",
        "input": "",
        "output": "\n/***************************************************/\n/* This program finds the shortest path between nodes */\n/* in a networK. It has 8 internal procedures: */\n/* SETUP, CONNECT, FIND, PRINT_ALL, PRINT_PATHS, */\n/* SHORTEST_DISTANCE, PRINT_ROUTE, and FREE_ALL. */\n/******************************************************/\n\nnetwork:\n   procedure options(Main);\n   %replace\n      true by '1'b,\n      false by '0'b,\n      citysize by 20,\n      infinite by 32767;\n\n   declare\n    sysin file;\n\n   declare \n      1 city_node based,\n        2 city_name character(citysize) varying,\n        2 total_distance fixed,\n        2 investigate bit,\n        2 city_list pointer,\n        2 route_head pointer;\n\n   declare \n      1 route_node based,\n        2 next_city pointer,\n        2 route_distance fixed,\n        2 route_list pointer;\n\n   declare\n      city_head pointer;\n\n   do while (true);\n      call setup();\n      if city_head = null then stop;\n      call print_all();\n      call print_paths();\n      call free_all();\n   end;\n/******************************************************/\n/* This procedure reads two cities and then calls the */\n/* procedure CONNECT to establish the connection (in */\n/* both directions) between the cities. */\n/******************************************************/\n  setup:\n    procedure;\n    declare \n      distance fixed,\n      (city1, city2) character(citysize) varying;\n\n    on endfile(sysin) goto eof;\n    city_head = null;\n    put skip list('Type `City1, Dist, City2;` ');\n    put skip;\n    do while (true);\n        get list(city1, distance, city2);\n        call connect(city1, distance, city2);\n        call connect(city2, distance, city1);\n    end;\n    eof:\n  end setup;\n/******************************************************/\n/* This procedure establishes a single route_node to */\n/* connect the first city to the second city by */\n/* calling the FIND procedure twice; once for the */\n/* first city and once for the second city. */\n/******************************************************/\n  connect:\n    procedure (source_city, distance, destination_city);\n    declare \n        source_city character(citysize) varying,\n        destination_city character(citysize) varying,\n        distance fixed,\n        (r, s, d) pointer;\n\n    s = find(source_city);\n    d = find(destination_city);\n    allocate route_node set (r);\n    r -> route_distance = distance;\n    r -> next_city = d;\n    r -> route_list = s -> route_head;\n    s -> route_head = r;\n  end connect;\n/**************************************************/\n/* This procedure searches the list of cities and */\n/* returns a pointer to the re9uested city_node. */\n/**************************************************/\n  find:\n    procedure (city) returns (pointer);\n    declare\n        city character(citysize) varying,\n        (p,q) pointer;\n\n    do p = city_head;\n        repeat (p -> city_list) while (p ^= null);\n        if city = p -> city_name then\n          return (p);\n    end;\n    allocate city_node set (p);\n    p -> city_name = city;\n    p -> city_list = city_head;\n    city_head = p;\n    p -> total_distance = infinite;\n    p -> route_head = null;\n    return (p);\n  end find;\n\n/**********************************************/\n/* This procedure starts at the city head and */\n/* displays all the cities in the city list. */\n/**********************************************/\n  print_all:\n    procedure;\n    declare\n        (p, q) pointer;\n\n    do p = city_head\n        repeat (p -> city_list) while (p ^= null);\n        put skip list(p -> city_name,':');\n        do q = p -> route_head\n            repeat (q -> route_list) while (q ^= null);\n          put skip list(q -> route_distance, ' Miles to ', q -> next_city -> city_name);\n        end;\n    end;\n  end print_all;\n  /******************************************************/\n  /* This procedure reads a destination city, calls the */\n  /* SHORTEST_DISTANCE procedure, and sets the */\n  /* total_distance field in each city_node to the */\n  /* total distance froM the destination city, */\n  /*************~****************************************/\n  print_paths:\n      procedure;\n      declare\n          city character(citysize) varying;\n\n      on endfile(sysin) goto eof;\n      do while (true);\n          put skip list('Type Destination ');\n          get list(city);\n          call shortest_distance(city);\n          on endfile(sysin) goto eol;\n          do while (true);\n              put skip list('Type Start ');\n              get list(city);\n              call print_route(city);\n          end;\n          eof: end print_paths;\n          eol: revert endfile(sysin);\n      end;\n  end print_paths\n/******************************************************/\n/* This procedure is the heart of the pro!:lraM. It */\n/* taKes an input city, the destination, and COMPutes */\n/* the MiniMuM total distance froM every city in the */\n/* networK to the destination. It then records this */\n/* MiniMuM value in the total_distance field of every */\n/* city_node                                          */\n/******************************************************/\n  shortest_distance:\n      procedure (city);\n      declare\n          city character(citysize) varying;\n      declare\n          bestp pointer,\n          (d, bestd) fixed,\n          (p, q, r) pointer;\n\n      do p = city_head\n          repeat (p -> city_list) while (p ^= null);\n          p -> total_distance = infinite;\n          p -> investigate = false;\n      end;\n      p = find(city);\n      p -> total_distance = 0;\n      p -> investigate = true;\n      do while (true);\n          bestp = null;\n          bestd = infinite;\n          do p = city_head\n              repeat (p -> city_list) while (p ^= null);\n              if p -> investigate then\n                  do;\n                    if p -> total_distance < bestd then\n                        do;\n                            bestd = p -> total_distance;\n                            bestp = p;\n                        end;\n                  end;\n          end;\n          if bestp = null then return;\n          bestp -> investigate = false;\n          do q = bestp -> route_head\n              repeat (q -> route_list) while (q ^= null);\n              r = q -> next_city;\n              d = bestd + q -> route_distance;\n              if d < r -> total_distance then\n                  r -> total_distance = d;\n                  r -> investigate = true;\n              end;\n          end;\n      end;\n  end shortest_distance;\n/***********************************************/\n/* This procedure displays the best route frOM */\n/* the input city to the destination. */\n/***********************************************/\n\n  print_route:\n      procedure (city);\n      declare\n          city character(citysize) varying;\n      declare\n          (p, q) pointer,\n          (t, d) fixed;\n\n      p = find(city);\n      do while (true);\n          t = p -> total_distance;\n          if t = infinite then\n              do;\n                put skip list('(No Connection)');\n                return;\n              end\n          if t = 0 then\n              return;\n          put skip list(t,' Miles remain');\n          q = p -> route_head;\n          do while (q ^= null);\n              p = q -> next_city;\n              d = q -> route_distance;\n              if t = d + p -> total_distance then\n                  do;\n                      put list(d || ' Miles to ' || p -> city_name);\n                      q = null;\n                  end\n              else\n                  q = q -> route_list;\n          end;\n      end;\n    end print_route;\n/**************************************************/ \n/* This procedure frees all the storage allocated */\n/* by the prOgraM while processing the networK. */\n/**************************************************/\n  free_all:\n      procedure;\n      declare\n          (p, q) pointer;\n      do p = city_head\n          repeat (p -> city_list) while (p ^= null);\n          do q = p -> route_head\n              repeat (q -> route_list) while (q ^= null);\n              free q -> route_node;\n          end;\n          free p -> city_node;\n      end;\n  end free_all;\n\nend network;\n"
    },
    {
        "instruction": "Write a PL/I program to fin the factorial of a number using iteration.",
        "input": "",
        "output": "/********************************************/\n/* This program evaluates the Factorial */\n /* function (n!) using iteration,\t\t*/\n/****************************************/ \nifact:\nprocedure options (main);\ndeclare\n\t(i, n, F) fixed;\ndo i = 0 by 1;\n\tF = 1;\nDo n= i to 1 by -1;\n\tF=n* F;\nend;\nput edit('factorial(',i, ')=',F)\n\t(skip, a,f(2), a, f(7));\nend;\nend ifact;\n"
    },
    {
        "instruction": "Write a PL/I program to fin the factorial of a number using recusrion.",
        "input": "",
        "output": "\n/********************************************/\n/* This program evaluates the Factorial */\n /* function (n!) using iteration,\t\t*/\n/****************************************/ \nrfact:\n    procedure options (main);\n    declare\n        i fixed;\n    do i = 0 repeat(i+1);\n        put skip list ('factorial(',i,')' = ',factorial(i));\n    end;\n    stop;\n    factorial:\n        procedure(i) returns(fixed) recursive;\n        declare\n            i fixed;\n        if i=0 then return (1);\n        return (i*factorial(i-1));\n    end factorial;\nend rfact;\n"
    },
    {
        "instruction": "Write a PL/I program to fin the factorial of a number using recusrion and FIXED DECIMAL.",
        "input": "",
        "output": "\n/********************************************/\n/* This program evaluates the Factorial */\n /* function (n!) using iteration and FIXED DECIMAL.*/\n/****************************************/ \ndfact:\n    procedure options (main);\n    declare\n        i fixed;\n    do i = 0 repeat(i+1);\n        put skip list ('factorial(',i,')' = ',factorial(i));\n    end;\n    stop;\n    factorial:\n        procedure(i) returns(fixed decimal(15,0)) recursive;\n        declare\n            i fixed;\n        if i=0 then return (1);\n        return (decimal(i,15)*factorial(i-1));\n    end factorial;\nend dfact;\n"
    },
    {
        "instruction": "Write a PL/I program to fin the factorial of a number using recusrion and FLOAT BINARY.",
        "input": "",
        "output": "\n/********************************************/\n/* This program evaluates the Factorial function*/\n/*  (n!) using iteration and FLOAT BINARY.*/\n/****************************************/ \ndfact:\n    procedure options (main);\n    declare\n        i fixed;\n    do i = 0 repeat(i+1);\n        put skip list ('factorial(',i,')' = ',factorial(i));\n    end;\n    stop;\n    factorial:\n        procedure(i) returns(float) recursive;\n        declare\n            i fixed;\n        if i=0 then return (1);\n        return (i*factorial(i-1));\n    end factorial;\nend dfact;\n"
    },
    {
        "instruction": "Write a PL/I program for the Ackermann function.",
        "input": "",
        "output": "\n/***************************************************/\n/* This program evaluates the Ackermann function */\n/* A(m,n), and increases the size of the stack */\n/* because of the large number of recursive calls. */\n/***************************************************\nack:\n    procedure options(main,stacK(2000));\n    declare\n        (m,maxm,n,maxn) fixed;\n\n    put sKip list('Type max m,n: ');\n    get list(maxm,maxn);\n    put sKip\n        lis t ('    ',(decimal(n,4) do n=O to maxn))\n    do m = 0 to maxm;\n        put sKip list(decimal(m,4),': ');\n        do n = 0 to maxn;\n            put list (decimal (ackermann(m,n),4)); \n        end;\n    end;\n    stop;\n\n    ackermann:\n            procedure(m,n) returns(fixed) recursive\n            declare (m,n) fixed;\n            if m = 0 then\n                return(n+1);\n            if n = 0 then\n                return(ackermann(m-1,1);\n            return(ackermann(m-1,ackermann(m,n-1)));\n    end ackermann;\nend ack;\n"
    },
    {
        "instruction": "Write an expression evaluation program in PL/I.",
        "input": "",
        "output": "/***************************************************/\n/* This program evaluates an arithmetic expression */\n/* using recursion. It contains two procedures. GNT */\n/* obtains the input expression consisting of separate */\n/* tokens, and EXP that performs the recursive */\n/* evaluation of the tokens in the input line. */\n/*****************************************************/\nexpression:\n    procedure options (main);\n    declare\n        sysin file,\n        value float,\n        token character (10) varying;\n    \n    on endfile (sysin)\n    stop;\n\n    on error(1) /* conversion or signal */\n    begin;\n        put skip list('Invalid Input at ',token);\n        get skip;\n        goto restart;\n    end;\n\n    restart:\n        do while('1'b);\n            put skip(3) list('Type expression: ');\n            value = exp();\n            put skip list('Value is:',value);\n        end;\n    gnt:\n        procedure;\n            get list(token);\n    end gnt;\n\n    exp:\n        procedure returns(float binary) recursive;\n        declare x float binary;\n        call gnt();\n        if token = '(' then\n            do;\n                x = exp();\n                call gnt();\n                if token ='+' then \n                    x= x + exp();\n                else\n                if token = '-' then\n                    x=x - exp() ;\n                else\n                if token = '*' then\n                    x = x * exp();\n                else\n                if token = '/' then\n                x= x / exp();\n                else\n                signal error (1);\n                call gnt ();\n                if token ^= ')' then\n                    signal error (1);\n            end;\n        else\n            x = token;\n        return (x);\n    end exp\nend expression;\n"
    },
    {
        "instruction": "Write an expression program in PL/I which consist of seperate tokens.",
        "input": "",
        "output": "\n/*****************************************************/\n/* This program evaluates an arithmetic expression */\n/* usin~ recursion. It contains an expanded version */\n/* of the GNT procedure that obtains an expression */\n/* containing separate toKens, EXP then recursively */\n/* evaluates the toKens in the input line. /\n/*****************************************************/\nexpression:\n    procedure options(Main);\n\n    %replace\n        true by '1'b;\n\n    declare\n        sysin file,\n        value float,\n        (token character(10), line character(80)) varying static initial(' ');\n\n    on endfile(sysin)\n        stop;\n\n    on error(1)  /* conversion or signal */\n        put skip list('Invalid input at', token);\n        token = ' '; line = ' ';\n        goto restart;\n    end;\n\n    restart:\n        do while (true);\n            put skip(3) list('Type expression: ');\n            value = exp();\n            put edit('Value is: ', value) (skip, a, f(10, 4));\n        end;\n\n    gnt:\n        procedure;\n        declare\n            i fixed;\n\n        line = substr(line, length(token) + 1);\n        do while (true);\n            if line = ' ' then\n                get edit(line) (a);\n                i = verify(line, ' ');\n            if i = 0 then\n                line = ' ';\n            else\n                do;\n                    line = substr(line, i);\n                    i = verify(line, '0123456789. ');\n                    if i = 0 then\n                        token = line;\n                    else if i = 1 then\n                        token = substr(line, 1, 1);\n                    else\n                        token = substr(line, 1, i - 1);\n                    return;\n                end;\n        end;\n    end gnt;\n\n    exp:\n        procedure returns (float binary) recursive;\n        declare x float binary;\n        call gnt();\n        if token = '(' then\n            do;\n                x = exp();\n                call gnt();\n                if token = '+' then\n                    x = x + exp();\n                else\n                if token = '-' then\n                    x = x - exp();\n                else\n                if token = '*' then\n                    x = x * exp();\n                else\n                if token = '/' then\n                    x = x / exp();\n                else\n                    signal error(1);\n                call gnt();\n                if token ^= ')' then\n                    signal error(1);\n            end;\n        else\n            x = token;\n        return (x);\n    end exp;\nend expression;\n"
    },
    {
        "instruction": "Write a PL/I program that illustrates ENTRY variables and constants.",
        "input": "",
        "output": "\n/************************************************/\n/* This program illustrates ENTRY variables and */\n/* constants.                                   * /\n/*************************************************/\ncall:\n    procedure options (main);\n    declare\n        f (3) entry(float) returns(float) variable,\n        a entry(float) returns(float),\n        i fixed, x float;\n    \n    f(1) = a;\n    f(2) = b;\n    f(3) = c;\n    do i = 1 to 3;\n        put skip list('Type x ');\n        get list(x);\n        put listl'f(',i,')=',f(i)(x));\n    end;\n    stop;\n\n    b:\n        procedure(x) returns(float); /* internal procedure */ \n        declare x float;\n        return(2*x + 1);\n    end b;\n    c:\n        procedure(x) returns(float); /* internal procedure */ \n        declare x float;\n        return(sin(x));\n    end c;\nend call;\n"
    },
    {
        "instruction": "Write a PL/I program tha performs matrix conversion.",
        "input": "",
        "output": "/*****************************************************/\n/* This program is the main module in a program that */\n/* performs matrix inversion. It calls the entry */\n/* constant INVERT which does the actual inversion. */\n/*****************************************************/\nmaininvt:\n    procedure options(main);\n    %replace\n        true by '1'b,\n        false by '0'b;\n        %replace\n        maxrow by 26,\n        maxcol by 40;\n\n    declare\n        mat(maxrow, maxcol) float binary(24),\n        (i, j, n, m) fixed(6),\n        var character(26) static initial('abcdefghijklmnopqrstuvwxyz'),\n        invert entry\n        ((maxrow, maxcol) float(21), fixed(6), fixed(6));\n\n    put list('Solution of Simultaneous Equations');\n        do while (true);\n            put skip(2) list('Type rows, columns: ');\n            get list(n);\n\n            if n = 0 then\n                stop;\n\n            get list(m);\n\n            if n > maxrow ! m > maxcol then\n                put skip list('Matrix is too large');\n            else\n                do;\n                    put skip list('Type Matrix of Coefficients');\n                    put skip;\n                    do i = 1 to n;\n                        put list('Row', i,':');\n                        get list((mat(i, j) do j = 1 to n));\n                    end;\n\n                    put skip list('Type Solution Vectors');\n                    put skip;\n\n                    do j = n + 1 to m;\n                        put list('Variable',substr(var, j - n, 1), ': ');\n                        get list((mat(i, j) do i = 1 to n));\n                    end;\n\n                    call invert(mat, n, m);\n                    put skip(2) list('Solutions: ');\n\n                    do i = 1 to n;\n                        put skip list(substr(var, i, 1),'= ');\n                        put edit((mat(i, j) do j = n + 1 to m))\n                            (f(8, 2));\n                    end;\n\n                    put skip(2) list('Inverse Matrix is');\n\n                    do i = 1 to n;\n                        put skip edit((mat(i, j) do j = 1 to n))\n                        (x(3), 6f(8, 2)),skip);\n                    end;\n                end;\n        end;\n\n    end maininvt;\n\n    invert:\n        procedure(a, r, c);\n            %replace\n            maxrow by 26,\n            maxcol by 40;\n\n        declare\n            (d, a(maxrow, maxcol)) float binary(24),\n            (i, j, k, r, c) fixed binary(6);\n\n        do i = 1 to r;\n            d = a(i, i);\n\n            do j = 1 to c - 1;\n                a(i, j) = a(i, j + 1) / d;\n            end;\n            a(i, c) = 1 / d;\n\n            do k = 1 to r;\n                if k ^= i then\n                do;\n                    d = a(k, i);\n                    do l = 1 to c - 1;\n                        a(k, j) = a(k, l + 1) - a(i, l) * d;\n                    end;\n                end;\n            end;\n        end;\n\n    end invert;"
    },
    {
        "instruction": "Can you write a sapmle program for a customer who has taken a loan of $500 on an interest rate of 14%. He wants to find out how many time will it take for him ti repay the loan?",
        "input": "",
        "output": "/*******************************************************/\n/* This program produces a schedule of loan payments*/\n/* using the following algorithm: if P= loan payment, */\n/* i = interest, and PMT is the monthly payment then */\n/* P= (P + (i*p) - РМТ).\t\t\t\t\t\t* /\n/*********************************************************/\nloan1:\nprocedure options (main)I;\ndeclare\nm\tfixed binary, \ny\tfixed binary,\nP \tfixed decimal (11,2), \nPMT fixed decimal (6,2),\ni \tfixed decimal (4,2);\n\ndo while ( ‘1’ b);\nput skip list('Principal ');\nget list (P)I;\nput list(‘Interest '); \nget list(i);\nput list (‘Payment\t’) \nget list (PMT);\nm = 0;\ny = 0;\ndo while (P > 0);\nif mod(m,12) = 0 then\ndo;\ny=y + 1;\nput skip list('Year',y);\nend;\nM =M + 1;\nput skip list(m,P);\nP= P + round(i*P / 1200, 2);\nif P < PMT\n\tthen PMT = P;\nput list (PMT) ;\nP = P - PMT;\n\t\tend;\nend;\nend loan1\n"
    },
    {
        "instruction": "Write a PL/I program for ANNUITY problem.",
        "input": "",
        "output": "\n/*******************************************************/\n/* This prograM COMPutes either the present valueIPV), */\n/* the paYMentIPMT), or the nUMber of periods in an */\n/* ordinary annuity,                                    */\n/*******************************************************/\nannuity:\n    procedure options(Main);\n    %replace\n        clear by '^z',\n        true by '1'b;\n\n    declare\n        PMT fixed decimal(7, 2),\n        PV fixed decimal(9, 2),\n        IP fixed decimal(6, 6),\n        i float binary,\n        yi float binary,\n        n float binary,\n        n fixed;\n\n    declare\n        ftc entry(float binary(24)) returns(character(17) varying);\n\n    put list(clear, '^i^iORDINARY ANNUITY');\n    put skip(2) list(^i'Enter Known Values; or 0, on Each Iteration');\n\n    on error\n        begin;\n            put skip list('^iInvalid Data, Re-enter');\n            goto retry;\n        end;\n\n    retry:\n    do while (true);\n        put skip(3) list('^iPresent Value ');\n        get list(PV);\n        put list('^iPayment ');\n        get list(PMT);\n        put list('^iInterest Rate ');\n        get list(yi);\n        i = yi / 1200;\n        put list('^iPay Periods ');\n        get list(n);\n\n        if PV = 0 | PMT = 0 then\n            x = 1 - 1 / (1 + i)*/n;\n\n        if PV = 0 then\n            do;\n                PV = PMT * dec(ftc(x / i) 15, 6);\n                put edit('^iPresent Value is ', PV) (a, p'$$$,$$$,$$$V.99');\n            end;\n        \n        /***********************/\n        /* Compute the payment */\n        /***********************/\n\n        if PMT = 0 then\n            do;\n                PMT = PV * dec(ftc(i / x) 15, 8);\n                put edit('^iPayment is ', PMT) (a, p'$$,$$$,$$$V.99');\n            end;\n        /***********************/\n        /* Compute number of periods */\n        /***********************/\n        if n = 0 then\n            do;\n                IP = ftc(i);\n                x = char(PV * IP / PMT);\n                n = ceil(-log(1 - x) / log(1 + i));\n                put edit(n, '^iPay Periods') (a, p'ZZZ9', a);\n            end;\n    end;\n\nend annuity;\n\n"
    },
    {
        "instruction": "Write a PL/I program to computea schedule of loan payments using elaborate analysis and display formats.",
        "input": "",
        "output": "\n/*******************************************************/\n/* This program computes a schedule of loan payments, */\n/* using an elaborate analysis and display format, */\n/* It contains five internal procedures: DISPLAY */\n/*SUMMARY, CURRENT_YEAR, HEADER, and LINE         */\n/*******************************************************/\nloan2:\n    procedure options(Main);\n\n    replace true by '1'b,\n            false by '0'b,\n            clear by '^Z';\n\n    declare\n        end bit(1),\n        m fixed binary,\n        sm fixed binary,\n        sy fixed binary,\n        fm fixed binary,\n        dl fixed binary,\n        P fixed decimal(10,2),\n        PV fixed decimal(10,2),\n        PP fixed decimal(10,2),\n        PL fixed decimal(10,2),\n        PMT fixed decimal(10,2),\n        PMV fixed decimal(10,2),\n        INT fixed decimal(10,2),\n        YIN fixed decimal(10,2),\n        IP fixed decimal(10,2),\n        yi fixed decimal(4,2),\n        i  fixed decimal(4,2),\n        INF fixed decimal(4,3),\n        ci fixed decimal(15,14),\n        fi fixed decimal(7,5),\n        ir fixed decimal(4,2);\n\n    declare\n        name character(14) varying static initial('$con'),\n        output file;\n\n    put list(clear '^i^ iUMMARY OF PAYMENTS');\n\n    on undefinedfile(output)\n        begin;\n            put skip list('^i^icannot write to ', name);\n            goto open_output;\n        end;\n\n    open_output:\n    put skip(2) list('^i^iOutput File Name ');\n    get list(name);\n    if name = '$con' then\n        open file(output) title('$con') print pagesize(0);\n    else\n        open file(output) title(name) print;\n\n    on error\n        begin;\n            put skip list('^i^iBad Input Data, Retry');\n            goto retry;\n        end;\n\n    retry:\n    do while (true);\n        put skip(2) list('^i^iPrincipal ');\n        get list(PV);\n        P = PV;\n        put list('^i^iInterest ');\n        get list(yi);\n        i = yi;\n        put list('^i^iPayment ');\n        get list(PMV);\n        PMT = PMV;\n        put list('^i^i%Inflation ');\n        get list(ir);\n        fi = 1 + ir / 1200;\n        ci = 1.00;\n\n        put list('^i^iStarting Month ');\n        get list(sm);\n        put list('^i^iStarting Year ');\n        get list(sy);\n        put list('^i^iFiscal Month ');\n        get list(fm);\n        put edit('^i^iDisplay Level',\n                 '^i^iYr Results: 0,\n                 '^i^iYr Interest: 1,\n                 '^i^iAll Values: 2')\n            (skip, a);\n        get list(dl);\n        if dl < 0 | dl > 2 then \n            signal error;\n\n        m = sm;\n        y = sy;\n        IP = 0;\n        PP = 0;\n        YIN = 0;\n\n        if name = '' then\n            put file(output) page;\n        call header();\n\n        do while (P > 0);\n            INT = round(i * P / 1200, 2);\n            IP = IP + INT;\n            PL '= P;\n            P = P + INT;\n            if P < PMT then\n                PMT = P;\n            P = P - PMT;\n            PP = PP + (PL - P);\n            INF = ci;\n            ci = ci / fi;\n            if (P = 0 | dl > 1 | M = fM) then\n                do;\n                    put file(output) skip edit(':' , 100 * m + y) (a, p'99/99');\n                    call display(PL * INF, INT * INF, PMT * INF, PP * INF, IP * INF);\n                end;\n            if m = fm & dl > 0 then\n                call summary();\n\n            m = m + 1;\n            if m > 12 then\n                do;\n                    M = 1;\n                    y = y + 1;\n                    if y > 99 then\n                        y = 0;\n                end;\n        end;\n\n        if dl = 0 then\n            call line();\n        else \n        if ^end then\n            call summary();\n    end retry;\n/****************************************************/\n/* This procedure performs the output of the actual */\n/* parameters passed to it by the Main part of the */\n/* program.                                          */\n/****************************************************/\n    display:\n        procedure(a, b, c, d, e);\n        declare\n            (a, b, c, d, e) fixed decimal(10,2);\n\n        put file(output) edit\n            ('|' , a , '|' , b , '|' , c , '|' , d , '|' , e , '|')\n            (a, 2(2(p'$zz,zzz,zz9v.99', a), p'$zzz,zz9.v99', a));\n    end display;\n/*************************************************/\n/* This procedure computes the summary of yearly */\n/* interest.                                       */\n/*************************************************/\n    summary:\n        procedure;\n        end = true;\n        call current_year(IP - YIN);\n        YIN = IP;\n    end summary;\n\n/****************************************************/\n/* This procedure computes the interest paid during' */\n/* current Year.                                      */\n/****************************************************/\n    current_year:\n        procedure(l);\n        declare\n            yp fixed binary,\n            l fixed decimal(10,2);\n\n        yp = y;\n\n        if fm < 12 then yp = yp - 1;\n        call line();\n        put skip file(output) edit\n            (':',`Interest Paid During``',yp,'_``',y,' is ,I,':')\n            (a,x(15) ,2(a,p'99') ,a,p'$$$,$$$,$$9V.99' ,x(16) ,a);\n    end current_year;\n/***************************************************** */\n/* This procedure defines and prints out an elaborate */\n/* header format.                                    */\n/****************************************************/\n    header:\n        procedure;\n        put file(output) list(clear);\n        call line();\n        put file(ouput) skip edit\n            ('|','LOAN PAYMENT SUMMARY','|')\n            (a,x(19));\n        call line();\n        put file(output) skip edit\n            ('|','Interest Rate',yi,'%','Inflation Rate',ir,'%','|')\n            (a,x(15),2(a,p'b99v.99' ,a ,x(6)) ,x(9) ,a);\n        call line();\n        put file(output) skip edit\n        ('|Date |',' Principal |','Plus Interest|',' Payment |',\n            'Principal Paid|','Interest Paid |') (a);\n        call line();\n    end header;\n/***************************************************** **/\n/* This procedure prints out a series of dashed lines. */\n/***************************************************** **/\n    line:\n        procedure;\n        declare\n            i fixed bin;\n        put file(output) skip edit\n            ('____________','____________',\n            ('_______________' do i = 1 to 4)) (a);\n    end line;\nend loan2;\n"
    },
    {
        "instruction": "Write a PL/I program for depreciaition schedule including three different depreciation shcedules.",
        "input": "",
        "output": "/*******************************************************/\n/* This program calculates three kinds of depreciation */\n/* schedules: straight_line, sum_of_the_years, and     */\n/*double_declining.                                    */\n/*******************************************************/\ndepreciate:\n   procedure options(main);\n   %replace\n      clear_screen by '^z',\n      indent by 15,\n      ITC_rate by .1,\n      bonus_rate by .1,\n      bonus_max by 2000;\n   \n   declare\n      selling_price decima1(8,2),\n      adjusted_price decimal(8,2),\n      residual_value decima1(8 ,2),\n      year _alue decimal(8,2),\n      depreciation_value decimal(8 ,2),\n      total_depreciation decimal(8,2),\n      book_value decimal(8,2),\n      tax_rate decimal(3,2),\n      sales_tax decimal (8 ,2) ,\n      tax_bracket decimal(2),\n      FYD decimal(8,2),\n      ITC decimal (8 ,2) ,\n      bonus_dep decimal (8 ,2) ,\n      months_remaining decimal (2),\n      new character(4),\n      factor decimal(2,1),\n      years decimal(2),\n      year_sum decimal(3),\n      current_year decimal(2),\n      select_sched character(!);\n   declare\n      copy_to_list character(4),\n      output file variable,\n      (sysprint, list) file;\n\n   schedule (0) = error;\n   schedule (1) = straight_line;\n   schedule (2) = sum_of_years;\n   schedule (3) = double_declining;\n\n   open file(sysprint) stream print pagesize(0) title('$con');\n\n   do while ('1'b);\n      put list(clear_screen,'^i^i^iDepreciation Schedule');\n      put skip(3) list('^i^iSelling Price? ');\n      get list(selling_price);\n      put list('^i^iResidual Value? ');\n      get list(residual_value);\n      put list('^i^iSales Tax (%)? ');\n      get list(tax_rate);\n      put list('^i^iTax Bracket (%)? ');\n      get list(tax_bracket);\n      put list('^i^iProRate Months? ');\n      get list(months_remaining);\n      put list('^i^iHow Many Years? ');\n      get list(years);\n      put list('^i^iNew? (yes/no) ');\n      get list(new);\n      put edit('^i^iSchedule:', \n               '^i^iStraight Line (s)', \n               '^i^iSum-of-Years (y)', \n               '^i^iDouble Declining (d)? ') (a,skip);\n      get list(select_sched);\n      put list('^i^iList? (yes/no) ');\n      get list(copy_to_list);\n      if copy_to_list = 'yes' then\n         open file(list) stream print title('$lst');\n      factor = 1.5;\n      if new = 'yes' then\n         factor = 2.0;\n      sales_tax = decimal(selling_price * tax_rate,12,2)/ 100 + .005;\n      if new = 'yes' | selling_price <= 100000.00 then\n         ITC = selling_price * ITC_rate;\n      else\n         ITC = 100000 * ITC_rate;\n      bonus_dep = selling_price * bonus_rate;\n      if bonus_dep > bonus_max then\n         bonus_dep = bonus_max;\n      put list(clear_screen);\n      call display(sysprint);\n      if copy_to_list = 'yes' then\n         call display(list);\n      put skip list('^i^iType RETURN to Continue');\n      put skip(2);\n   end;\n\n   /***********************************************/\n   /* This procedure displays the various          */\n   /* depreciation schedules. It calls the         */\n   /* appropriate schedule with an index into an   */\n   /* array of entry constants.                    */\n   /***********************************************/\n   display:\n      procedure(f);\n      declare\n         f file;\n      output = f;\n      call schedule(index(schedules,select_sched));\n   end display;\n\n   /***********************************************/\n   /* This is a global error recovery routine.     */\n   /***********************************************/\n   error:\n      procedure;\n      put file(output) edit('Invalid Schedule - Enter s, y, or d')\n                     (page,column(indent),x(8),a);\n      call line();\n   end error;\n\n   /***********************************************/\n   /* This procedure computes straight_line        */\n   /* depreciation.                                */\n   /***********************************************/\n   straight_line:\n      procedure;\n      adjusted_price = selling_price - bonus_dep;\n      put file(output) edit('S T R A I G H T  L I N E')\n                     (page,column(indent),x(11),a);\n      call header();\n      depreciation_value = adjusted_price - residual_value;\n      book_value = adjusted_price;\n      total_depreciation = 0;\n      do current_year = 1 to years;\n         year_value = decimal(depreciation_value/years,8,2) + .005;\n         if current_year = 1 then\n         do;\n            year_value = year_value * months_remaining / 12;\n            FYD = year_value;\n         end;\n         depreciation_value = depreciation_value - year_value;\n         total_depreciation = total_depreciation + year_value;\n         book_value = adjusted_price - total_depreciation;\n         call print_line();\n      end;\n      call summary();\n   end straight_line;\n\n   /***********************************************/\n   /* This procedure computes depreciation based   */\n   /* on the sum_of_the_years.                     */\n   /***********************************************/\n   sum_of_years:\n      procedure;\n      adjusted_price = selling_price - bonus_dep;\n      put file(output) edit('S U M  O F  T H E  Y E A R S')\n                     (page,column(indent),x(11),a);\n      call header();\n      depreciation_value = adjusted_price - residual_value;\n      book_value = adjusted_price;\n      total_depreciation = 0;\n      year_sum = 0;\n      do current_year = 1 to years;\n         year_sum = year_sum + current_year;\n      end;\n      do current_year = 1 to years;\n         year_value = decimal(depreciation_value *\n                     (years - current_year + 1) / year_sum,12,2) + .005;\n         if current_year = 1 then\n            do;\n               year_value = year_value * months_remaining / 12;\n               FYD = year_value;\n            end;\n         depreciation_value = depreciation_value - year_value;\n         total_depreciation = total_depreciation + year_value;\n         book_value = adjusted_price - total_depreciation;\n         call print_line();\n      end;\n      call summary();\n   end sum_of_years;\n\n   /***********************************************/\n   /* This procedure computes double_declining     */\n   /* depreciation.                                */\n   /***********************************************/\n   double_declining:\n      procedure;\n      adjusted_price = selling_price - bonus_dep;\n      put file(output) edit('D O U B L E  D E C L I N I N G')\n                     (page,column(indent),x(10),a);\n      call header();\n      depreciation_value = adjusted_price - residual_value;\n      book_value = adjusted_price;\n      total_depreciation = 0;\n      do current_year = 1 to years \n         while (depreciation_value > 0);\n         year_value = decimal(book_value / years,8,2) * factor + .005;\n         if current_year = 1 then\n            do;\n               year_value = year_value * months_remaining / 12;\n               FYD = year_value;\n            end;\n         if year_value > depreciation_value then\n            year_value = depreciation_value;\n         depreciation_value = depreciation_value - year_value;\n         total_depreciation = total_depreciation + year_value;\n         book_value = adjusted_price - total_depreciation;\n         call print_line();\n      end;\n      call summary();\n   end double_declining;\n\n   /***********************************************/\n   /* This procedure prints an output header       */\n   /* record.                                      */\n   /***********************************************/\n   header:\n      procedure;\n      declare\n         new_or_used character(5);\n      if new = 'yes' then\n         new_or_used = 'New';\n      else\n         new_or_used = 'Used';\n      put file(output) edit('--------------------------------------------------',\n                           '|',selling_price+sales_tax,new_or_used,\n                           residual_Value,'Residual Value|',\n                           '|',months_remaining,'Months Left',\n                           tax_rate, '% Tax',tax_bracket,'% Tax Bracket|')\n                     (2(skip,column(indent),a),\n                     2(p'$$$,$$$,$$9.V99',a),\n                     skip,column(indent),a,x(5),f(2),a,\n                     2(x(2),p'999',a));\n      put file(output) edit('--------------------------------------------------',\n                           ' | Y | Depreciation | Depreciation | Book Value |',\n                           ' | r | For Year     | Remaining    |            |')\n                     (skip,column(indent),a);\n      \n   end header;\n\n   /***********************************************/\n   /* This procedure prints the current line.      */\n   /***********************************************/\n   print_line:\n      procedure;\n      put file(output) edit(\n         '|',current_year,\n         ' |',year_value,\n         ' | ',depreciation_value,\n         ' | ',book_value,' |')\n         (skip,column(indent),a,f(2),4(a,p'$z,zzz,zz9v.99'));\n   end print_line;\n\n   /***********************************************/\n   /* This procedure prints the summary of values  */\n   /* for each type of depreciation schedule.      */\n   /***********************************************/\n   summary:\n      procedure;\n      declare \n         adj_ITC decimal(8,2),\n         total decimal(8,2),\n         direct decimal(8,2);\n      call line();\n      adj_ITC = ITC * 100 / tax_bracket;\n      total = FYD + sales_tax + adj_ITC + bonus_dep;\n      direct = total * tax_bracket / 100;\n      put file(output) edit(\n      '|       First Year Reduction in Taxable Income        |',\n      '-------------------------------------------------------',\n      '|       Depreciation            ',FYD,               '|',\n      '|       Sales Tax               ', sales_tax,        '|',\n      '|       ITC (Adjusted)          ', adj_ITC,          '|',\n      '|       Bonus Depreciation      ', bonus_dep,        '|',\n      '|       Total for First Year    ', total,            '|',\n      '|       Direct Reduction in Tax ', direct,           '|')\n      (2(skip,column(indent),a), 2(4(skip,column(indent),a,p'$z,zzz,zz9v.99',x(3),a),\n      skip,column(indent),a));\n      call line();\n   end summary;\n   /**********************************************/\n   /* This procedure prints a  ine of dashes.   */\n   /**********************************************/\n   line:\n      procedure;\n      put file (output) edit(\n      '-------------------------------------------------')\n      (skip,column(indent),a);\n   end line;\nend depreciate;\n"
    },
    {
        "instruction": "Write a PL/I program to test an assembly routine to do floating-point division.",
        "input": "",
        "output": "/*****************************************************/\n/* This program tests an assembly language routine to */\n/* do floating-point division.                        * /\n/******************************************************/\ndtest:\n   procedure options (main);\n   declare\n      div2 entry(fixed (7) ,float),\n      i fixed(7),\n      f float;\n   do i = 0 by 1;\n      f = 100;\n      call div2(i,f);\n      put skip list('100 / 2 **',i, '=',f);\n   end;\nend dtest;\n"
    },
    {
        "instruction": "Write a PL/I program to test an assembly routine called FDIV2 which returns a FLOAT BINARY value.",
        "input": "",
        "output": "/*****************************************************/\n/* This program tests the assembly language routine     */\n/* called FDIV2 ahich returns a FLOAT BINARY value.    * /\n/******************************************************/\nfdtest:\n   procedure options (main);\n   declare\n      div2 entry(fixed (7) ,float) returns(float),\n      i fixed(7),\n      f float;\n   \n   do i = 0 by 1;\n      put skip list('100 / 2 **',i, '=',fdiv2(i,100));\n   end;\nend fdtest;\n"
    },
    {
        "instruction": "Write a PL/I program to test TOTWDS, MAXWDS and ALLWDS functions from the run-time subroutine library.",
        "input": "",
        "output": "/*****************************************************/\n/* This program tests the TOTWDS, MAXWDS, and ALLWDS  */\n/* functions from the Run-time Subroutine Library.    */\n/******************************************************/\n\nalltst:\n   procedure options (main);\n   declare\n      totwds entry returns(fixed (15)),\n      maxwds entry returns(fixed (15)),\n      allwds entry(fixed (15)) returns (pointer);\n   declare\n      allreq fixed(15),\n      memptr ptr;\n      meminx fixed (15),\n      memory (0:0) bit(16) based(memptr);\n   do while ('1 'b);\n      put edit (totwds(), ' Total Words Available',\n               maxwas(), ' Maximum Segment Size',\n               'Allocation Size? ') (2(skip,f(6),a),skip,a);\n      get list(allreq);\n      memptr = allwds (allreq);\n      put edit('Allocated', allreq,' Words at ',unspec (memper))\n               (sKip,a,f(6),a,b4) ;\n      /* clear memory as example */\n      do meminx = 0 to allreq-1;\n         memory(meminx) = '0000'b4;\n      end;\n   endi\nend alltst;\n"
    },
    {
        "instruction": "Write a program in PL/I to test the STKSIZ function while evaluating a RECURSIVE procedure.",
        "input": "",
        "output": "/*******************************************#**********/\n/* This program tests the STKSIZ Punction while */\n/* evaluating a RECURSIVE procedure.            */\n/******************************************************/\nack:\n   procedure options(main,stack (2000));\n   declare\n      (mon) fixed,\n      (maxm,maxn) fixed,\n      ncalls decimal(6),\n      (curstack, stacksize) fixed,\n      stksiz entry returns (fixed);\n   put skip list('Type max m,n: ');\n   get list (maxm,maxn);\n   do m = O to maxm;\n      do n = 0 to maxn;\n         ncalls      = 0;\n         curstack    = 0;\n         stacksize   = 0;\n         put edit('Ack(',m,',',n,')=',ackermann(m,n),\n            ncalls,' Calls,',stacksize,' Stack Bytes')\n            (skip,a,2(f(2) ,a),f(6),f(7),a,f(4),a);\n      end;\n   end;\n   stop;\n\n   ackermann:\n      procedure (m,n) returns(fixed) recursive;\n      declare\n         (m,n) fixedi\n      ncalls = ncalls + 11\n      curstack = stksiz ();\n      if curstack > stacksize then\n         stacksize = curstack;\n      if m= 0 then\n         return(n+1);\n      if n= 0 then\n         return (ackermann (m-1,1));\n      return(ackermann(m-1, rackermann (m,n-1)));\n   end ackermann;\nend ack;\n"
    },
    {
        "instruction": "Write a PL/I code which showcase the skeleton for parameter passing in PL/I.",
        "input": "",
        "output": "Below is a sample PL/I code which represents the skeleton of parameter passing in PL/I\nmain:\n\tproceudre options(main);\n    declare\n\t\ta float binary;\n        \t|\n        \t|\n    call low_sub(a); /* pass by reference */\n        |\n    call middle_sub((a)); /* pass by value */\n        |\n    call high_sub(a); /* pass by reference */\n        |\n        |\n    low_sub:\n        procedure;\n        declare\n            x float binary;\n        |\n        |\n    end low_sub;\n    \n    middle_sub:\n        procedure;\n        declare\n            x float binary;\n        |\n        |\n    end middle_sub;\n    \n    high_sub:\n        procedure(x);\n        declare\n            (x,my_x) float binary;\n        my_x = x; /* reassign using local variable */\n        |\n        |\n    end high_sub;\nend main;"
    },
    {
        "instruction": "Write an simple example of assignment statements in PL/I.",
        "input": "",
        "output": "assign:\n\tprocedure options(main);\n\tdeclare\n\t    p pointer,\n\t    i fixed binary(7),\n\t    r bit(16),\n\t    s bit(16) based,\n\t    (vu, v) float binary(24),\n\t    A(5,2) character(2),\n\t    B(5,2) character(2),\n\t    C character(2),\n\t    1 w,\n\t        2 x fixed binary,\n\t        2 y bit(16),\n\t    1 z,\n\t        2 x fixed binary,\n\t        2 y bit(16);\n\t\t\n\n    u = u + v; /* simple assignment */\n    A = B; /* array aggregate assignment */\n    A(3) = B(4); /* cross-sectional reference */\n    w = z; /* structure aggregate assignment */\n    p -> s = (r=w,y); /* pointer-qualified reference */\n    w,x = w,x + z,x; /* partially qualified aggregate reference */\n    unspec(Iw,y)’) = unspec(A(5,1)); /* pseudo-variable reference */ \n    substr(C,i+l,3) = substr(C,10,3); /* pseudo-variable reference */ \n    A(2*i+l) = B(4); /* variable is expression */\n\nend assign;"
    },
    {
        "instruction": "Show me and example of structures in PL/I.",
        "input": "",
        "output": "declare\n\t1 employee,\n\t    2 name_address,\n\t\t\t3 name,\n\t\t\t\t4 first character(10),\n                4 middle-initial character(1),\n                4 last character(20),\n            3 address,\n\t\t\t\t4 street character(40),\n                4 city character(10),\n                4 state character(2),\n                4 zip_code character(5),\n        2 position\n\t\t\t3 department_no character(3),\n            3 job_title character(20),\n        2 salary fixed decimal(8,2),\n        2 number_of_dependents fixed,\n        2 health_plan bit(1),\n        2 date_hired character(8);"
    },
    {
        "instruction": "Can you show a sample code which have an external procedure and internal procedure?",
        "input": "",
        "output": "/************External procedure*****************************/\na : \nprocedure(x) returns(float); /* external procedure */\ndeclare x float;\nreturn (x/2);\nend a;\n\n\n/**********************the CALL program******************/\ncall:\n\tprocedure options (main);\n\tdeclare\n\t\tf(3) entry(float) returns(float) variable,\n\t\ta entry(float) returns(float); /* entry constant /*\n\tdeclare\n\t\tI fixed, x float;\n\tf(1) = a;\n\tf(2) = b;\n\tf(3) = c;\n\tdo i = 1 to 3;\n\tput skip list (‘Type x ’);\n\tget list(x);\n\tput list(‘f(‘,i,’) = ’,f(i)(x));\n\tend;\n\tstop;\n\n\tb :\n\tprocedure(x) returns(float); /* internal procedure */ \n\tdeclare x float;\n\treturn (2*x + 1);\n\tend b;\n\n\tс :\n\tprocedure(x) returns(float); /* internal procedure */\n\tdeclare x float;\n\treturn(sin(x));\n\tend c;\nend call;"
    },
    {
        "instruction": "Can you show an example for label variables.",
        "input": "",
        "output": "'chase_your_tail:\n\tprocedure options (main);\n\tdeclare\n\t\twherever label;\n\tthere:\n\t\twherever = here;\n\there:\n\t\twherever = there;\n\tgoto wherever;\nend chase your tail;"
    },
    {
        "instruction": "Show me a program that illustrates statements from each category.",
        "input": "",
        "output": "sample:\n\tprocedure options(main);\n\tdeclare\n\t    c character(10) varying;\n\n\tdo;\n\t    put skip list(‘Input: ‘);\n\t    get list(c);\n\t    c = upper(c); /* function reference*/\n\t    put skip list(‘Output: ’,c);\n\tend;\n\t\n\tbegin;\n\tdeclare\n\t    c float binary(24);\n\t    put skip list(‘Input: ‘);\n\t    get list(c);\n\t    call output(c); /* subroutine invocation */\n\tend;\n\tupper:\n\t        procedure(c) returns(character(10) varying;\n\t        declare\n\t\tc character(10) varying;\n\t        return(translate(c,’ABCDEFGHIJKLMNOPQRSTUVWXYZ’,’abcdefghijklmnopqrstuvwxyz’));\n\tend upper;\n\toutput:\n\t\tprocedure(c);\n\t\tdeclare\n\t\t    c float binary(24);\n\t\tput skip edit(c) (column(20),e(10.2));\n\tend output;\nend sample;"
    },
    {
        "instruction": "Write a program to copy one file into another file in PL/I language.",
        "input": "",
        "output": "/*******************************************#**********/\n/* This program copies one file to another using */ \n/* buffered I/O.                                */\n/******************************************************/\ncopy:\n   procedure options (main);\n   declare\n      (input_ file, output file) file;\n   open file (input_file) stream\n      environment(b(8192)) title('$1,$1');\n   open file loutput_file) stream output\n      environment(b(8192)) title ('$2.$2');\n   declare\n      buff character (254) varying;\n   do while ('1'b);\n      read file (input_file) into (buff);\n      write file (output_ file) from (buff);\n   end;\nend copy;"
    },
    {
        "instruction": "Write a PL/I  program to create a name and address file.",
        "input": "",
        "output": "/*****************************************************/\n/* This program creates a name and address file. The */\n/* data structure for each record is in the %INCLUDE */\n/* file RECORD.DCL.                                  */\n/*****************************************************/\ncreate:\n   procedure options(Main);\n   declare\n      1 record,\n         2 name  character(30) varying,\n         2 addr  character(30) varying,\n         2 city  character(20) varying,\n         2 state character(10) varying,\n         2 zip   fixed decimal(6),\n         2 phone character(12) varying;\n\n%replace\n   true  by '1'b,\n   false by '0'b;\n\n   declare\n      output file,\n      filename character(14) varying,\n      eofile bit(1) static initial(false);\n\n   put list('Name and Address Creation Program, File Name: ');\n   get list(filename);\n\n   open file(output) stream output title(filename);\n\n   do while (^eofile);\n      put skip(3) list('Name: ');\n      get list(name);\n      eofile = (name = 'EOF');\n      if ^eofile then\n         do;\n      /* write prompt strings to console */\n            put list('Address: ');\n            get list(addr);\n            put list('City, State, Zip: ');\n            get list(city, state, zip);\n            put list('Phone: ');\n            get list(phone);\n\n      /* data in memory, write to output file */\n            put file(output) list(name, addr, city, state, zip, phone);\n            put file(output) skip;\n         end;\n   end;\n   put file(output) skip list('EOF');\n   put file(output) skip;\nend create;"
    },
    {
        "instruction": "Write a PL/I program to read a name and addredd data file nad display the information on request.",
        "input": "",
        "output": "/***************************************************/\n/* This program reads a name and address data file */\n/* and displays the information on request.        */\n/***************************************************/\nretrieve:\n   procedure options(main);\n\n   declare\n      1 record,\n         2 name  character(30) varying,\n         2 addr  character(30) varying,\n         2 city  character(20) varying,\n         2 state character(10) varying,\n         2 zip   fixed decimal(6),\n         2 phone character(12) varying;\n\n   declare\n      true  by '1'b,\n      false by '0'b;\n\n   declare\n      (sysprint, input) file,\n      filename character(14) varying,\n      (lower, upper) character(30) varying,\n      eofile bit(1);\n\n   open file(sysprint) print title('$con');\n   put list('Name and Address Retrieval, File Name: ');\n   get list(filename);\n\n   do while (true);\n      lower = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA';\n      upper = 'zzzzzzzzzzzzzzzzzzzzzzzzZZZZZZ';\n      put skip(2) list('Type Lower, Upper Bounds: ');\n      get list(lower, upper);\n      if lower = 'EOF' then\n         stop;\n\n      open file(input) stream input environment(b(1024)) title(filename);\n      eofile = false;\n      do while (^eofile);\n         get file(input) list(name);\n         eofile = (name = 'EOF');\n         if ^eofile then\n            do;\n               get file(input) list(addr, city, state, zip, phone);\n               if name >= lower & name <= upper then\n                  do;\n                     put page skip(3) list(name);\n                     put skip list(addr);\n                     put skip list(city, state);\n                     put skip list(zip);\n                     put skip list(phone);\n                  end;\n            end;\n      end;\n      close file(input);\n   end;\nend retrieve;"
    },
    {
        "instruction": "Write a PL/I program to construct a database of employee record using a structure declaration.",
        "input": "",
        "output": "/***************************************************/\n/* This program constructs a database of employee  */\n/* records using a structure declaration.          */\n/***************************************************/\nenter:\n   procedure options(Main);\n\n   5replace\n      true  by '1'b,\n      false by '0'b;\n\n   declare\n      1 employee static,\n         2 name      character(30) varying,\n         2 address,\n            3 street character(30) varying,\n            3 city   character(10) varying,\n            3 state  character(12) varying,\n            3 zip    fixed decimal(5),\n         2 age       fixed decimal(3),\n         2 wage      fixed decimal(5,2),\n         2 hours     fixed decimal(5,2);\n\n   declare\n      1 default static,\n         2 street character(30) varying initial('(no street)'),\n         2 city character(10) varying initial('(no city)'),\n         2 state character(12) varying initial('(no state)'),\n         2 zip fixed decimal(5) initial(00000);\n\n   declare\n      emp file;\n\n   open file(emp) keyed output environment(f(128),b(8000)) title ('$1.EMP');\n\n   do while(true);\n      put list('Employee: ');\n      get list(name);\n\n      if name = 'EOF' then\n         do;\n            call write_it();\n            stop;\n         end;\n\n      address = default;\n      put list('Age, Wage: ');\n      get list(age, wage);\n      hours = 0;\n      call write_it();\n   end;\n\n   write_it:\n      procedure;\n      write file(emp) from(employee);\n   end write_it;\nend enter;\n"
    },
    {
        "instruction": "Write a program to read an employee record file and create another file of keys to access the records.",
        "input": "",
        "output": "/***************************************************/\n/* This program reads an employee record file and */\n/* creates another file of keys to access the records. */\n/***************************************************/\nkeyfile:\n   procedure option(main);\n   declare\n      1 employee static,\n         2 name character(30) varying;\n   declare\n      (input, keys) file,\n      k fixed;\n   open file(input) keyed environment(f(128),b(10000))\n      title('$1.emp');\n   open file(keys) stream output\n      linesize(60) title('$1.key');\n   do while('1');\n      read file(input) into(employee) keyto(k);\n      put skip list(k,name);\n      put file(keys) list(name,k);\n      if name = 'EOF' then\n         stop;\n   end;\nend keyfile;"
    },
    {
        "instruction": "Write a program to retrieve and update records in an employee database in PL/I.",
        "input": "",
        "output": "/*****************************************************/\n/* This program allows you to retrieve and update    */\n/* individual records in an employee database using  */\n/* a keyed file.                                     */\n/*****************************************************/\nupdate:\n   procedure options(Main);\n   declare \n      1 employee static,\n         2 name      character(30) varying,\n         2 address,\n            3 street character(30) varying,\n            3 city   character(10) varying,\n            3 state  character(12) varying,\n            3 zip    fixed decimal(5),\n         2 age       fixed decimal(3),\n         2 wage      fixed decimal(5,2),\n         2 hours     fixed decimal(5,1);\n\n   declare \n      1 keylist(100),\n         2 keyname character(30) varying,\n         2 keyval fixed binary;\n\n   declare \n      (i, endlist) fixed,\n      eolist bit(1) static initial('0'b),\n      matchname character(30) varying,\n      (emp, keys) file;\n\n   /* Open the employee file for update with direct access */\n   open file(emp) update direct environment(f(128))\n      title('$1.EMP');\n\n   /* Open the keys file as a stream */\n   open file(keys) stream environment(b(4000))\n      title('$1.KEY');\n\n   /* Read keys into keylist */\n   do i = 1 to 100 while (^eolist);\n      get file(keys) list(keyname(i), keyval(i));\n      eolist = keyname(i) = 'EOF';\n   end;\n\n   do while('1'b);\n      put skip list('Employee: ');\n      get list(matchname);\n      if matchname = 'EOF' then\n      stop;\n      do i = 1 to 100;\n         if matchname = keyname(i) then\n            do;\n               /* Read employee record with matching key */\n               read file(emp) into(employee)\n                  key(keyval(i));\n               put skip list('Address: ', street, city, state, zip);\n               put skip list(' ');\n               get list(street, city, state, zip);\n               put list('Hours: ', hours);\n               get list(hours);\n               /* Update employee record with new values */\n               write file(emp) from(employee)\n                  keyfrom(keyval(i));\n            end;\n      end;\n   end;\nend update;"
    },
    {
        "instruction": "Write a PL/I program to read an employee's database and print a list of paychecks.",
        "input": "",
        "output": "/*****************************************************/\n/* This program reads an employee data base and    */\n/* prints a list of paychecks                        */\n/*****************************************************/\n\nreport:\n   procedure options (main);\n   declare\n      1 employee static,\n         2 name      character (30) varying,\n         2 address,\n            3 street character (30) varying,\n            3 city   character(10) varying,\n            3 state  character (12) varying,\n            3 zip    fixed decimal(5),\n\n         2 age       fixed decimal(3),\n         2 wage      fixed decimal(5,2),\n         2 hours     fixed decimal(5,1);\n   \n   declare\n      i fixed,\n      dashes character (15) static initial\n      ('$-------------');\n      buff character 20) varying, \n      (grosspay, withhold) fixed decimal(7,2),\n      (repfile, emptile) filei\n\n   open file(empfile) Keyed environment (f(128),b(4000))\n      title ('$1,EMP');\n   open file(repfile) stream print environment(b(2000))\n      title ('$2.$2');\n   put listl'Set Top of Forms, Press Return');\n   get skip;\n   do while('1'b);\n      read file(empfile) into(employee);\n      if name = 'EOF' then\n         stop;\n      put file(repfile) skip(2);\n      buff = '[' !! name !! ']^m^j';\n      write file(repfile) from (buff);\n      grosspy = wage * hours;\n      withhold = grosspay * .15;\n      buff = grosspay - withhold;\n      do i=1 to 15\n         while (substr(buff,i,1) = ' ');\n      end;\n      substr(buff,1,i) = substr(dashes,1,i);\n      write file (repfile) from(buff);\n   end;\nend report;"
    },
    {
        "instruction": "write a PL/I program to shocase the concept of label constant and variables.",
        "input": "",
        "output": "/*****************************************************/\n/* This is a nonfunctional pro~raM. Its purpose is */\n/* to illustrate the connept of label constants and */\n/* variables.                                         */\n/*****************************************************/\nlabels:\n      procedure option(main);\n      declare\n         i fixed,\n         (x,y,z(3)) label;\n      x = lab1;\n      y = x;\n\n      goto lab1;\n      goto x;\n      goto y;\n\n      call P(lab2);\n      do i=1 to 3;\n         z(i) = c(i);\n      end;\n\n      i=2;\n      goto z(i);\n      goto c(i);\n\n      c(1);\n      c(2);\n      c(3);\n\n      lab2:;\n      lab2:;\n\n      P:\n         procedure (g);\n         declare\n            g label;\n         goto g;\n      end P;\nend labels;"
    },
    {
        "instruction": "Write a PL/I program to shocase how PL/I executes ON and REVERT statements.",
        "input": "",
        "output": "/*****************************************************/\n/* This program is nonfunctional, Its purpose is to */\n/* illustrate how PL/I executes the ON and REVERT statements */\n/*****************************************************/\nauto_revert:\n   procedure options (main);\n   declare\n      i fixed,\n      sysin file;\n   do i = 1 to 10000;\n      call P(i,exit);\n      exit:\n   end;\n\n   P:\n      procedure (index,lab) ;\n      declare\n         (t, index) fixed,\n         lab label;\n      on endfile(sysin)\n         goto lab;\n      put skip list(index,':');\n      get list(t);\n      if t = index then\n         goto lab;\n   end P; /* implicit REVERT supplied here */\nend auto_revert;"
    },
    {
        "instruction": "How can I copy my file to another file? Can you write a PL/I program for the same?",
        "input": "",
        "output": "You can do the copying of files using buffer I/O. Below is the sample code for that.\n/********************************************************\n* This program copies one file to another using */\n/* buffered I/O\t\t\t\t\t\t\t*/\n/******************************************************/\ncopy:\nprocedure options (main);\ndeclare\n\t(input_file, output_file) file;\nopen file (input_file) stream\n\tenvironment (b (8192)) title ('$1,$1');\nopen file (output_file) stream output\n\tenvironment (b (8192)) title ('$2,$2');\ndeclare\n\tbuff character (254) varying;\ndo while ('1'b);\n\tread file (input_file) into (buff);\n\twrite file (output_file) from (buff);\nend;\nend copy;"
    },
    {
        "instruction": "Write a PL/I program to evaluat apolynomial expression considering end-of-file condition.",
        "input": "",
        "output": "/*****************************************************/\n/* This program evaluates a polynomial expression */\n/* using FLOAT BINARY data.It also traps the end-of- */\n/* file condition for the file SYSIN.                 */\n/*******************************************************/\nPltpoly2:\n   procedure options (main);\n   %replace\n      false by '0'b,\n      true by '1'b;\n   declare\n      (x,y,z) float binary (24),\n      eofile bit(1) static initial(false),\n      sysin file;\n\n   on endfile(sysin)\n      eofile = true;\n   do while(truel;\n      put skip(2) lists'Type x,y,z: ');\n      get list(x,y,z);\n\n      if eofile then\n         stop;\n      put skip list('      2'); \n      put skip list('       x + 2y + z=',P(x,y,z));\n   end;\n   P:\n      procedure (x,y,z) returns (float binary (24));\n      declare\n         (x,y,z) float binary (24);\n      return (x*x+2*y+z);\n   end P;\nend fitpoly2;"
    },
    {
        "instruction": "Write a PL/I program tocopy a STREAM file on disk to a print file.",
        "input": "",
        "output": "\n/*****************************************************/\n/* This program copies a STREAM file on disk to a */\n/* PRINT file, and formats the output with a page */\n/* header, and line numbers.                      */\n/****************************************************/\ncopy: procedure options(Main);\n   declare \n      (sysin, sourcefile, printfile) file,\n      (pagesize, pagewidth, spaces, linenumber) fixed,\n      (line character(14), buff character(254)) varying;\n\n   /* Error handler for end-of-file on console input */\n   put list('^z   File to Print Copy Program');\n   on endfile(sysin) \n      go to typeover;\n\n   typeover:\n      /* Get number of lines per page */\n      put skip list('How Many Lines Per Page? ');\n      get list(pagesize);\n\n      /* Get number of column positions */\n      put skip list('How Many Column Positions? ');\n      get list(pagewidth);\n\n   /* Error handler for invalid input */\n   on error(1)\n      begin;\n         put list('Invalid Number, Type Integer');\n         go to getnumber;\n      end;\n\n   /* Get line spacing */\n   getnumber:\n      put skip list('Line Spacing (1=Single)? ');\n      get skip list(spaces);\n      revert error(1);\n\n   /* Get destination device/file */\n   put skip list('Destination Device/File: ');\n   get skip list(line);\n\n   /* Open print file */\n   open file(printfile) print pagesize(pagesize)\n      linesize(pagewidth) title(line);\n\n   /* Error handler for undefined source file */\n   on undefinedfile(sourcefile)\n      begin;\n         put skip list('''',line,''' isn''t a Valid Name');\n         go to retry;\n      end;\n\n   /* Retry getting source file */\n   retry:\n      put skip list('Source File to Print? ');\n      get list(line);\n\n      /* Open source file */\n      open file(sourcefile) stream environment(b(8000))\n         title(line);\n\n   /* Error handler for end-of-file on source file */\n   on endfile(sourcefile)\n      begin;\n         put file(printfile) page;\n         stop;\n      end;\n\n   /* Error handler for end-of-file on print file */\n   on endfile(printfile)\n      begin;\n         put skip list('^g^g^g^g Disk is Full');\n         stop;\n      end;\n\n   /* Error handler for end-of-page on print file */\n   on endpage(printfile)\n      begin;\n         put file(printfile) page skip(2)\n            list('PAGE', pageno(printfile));\n         put file(printfile) skip(2);\n      end;\n\n   /* Trigger end-of-page signal */\n   signal endpage(printfile);\n\n   /* Main loop to copy lines from source to print file */\n   do linenumber = 1 repeat(linenumber + 1);\n      get file(sourcefile) edit(buff) (a);\n      put file(printfile)\n         edit(linenumber, ':', buff) (f(5), x(1), a(2), a);\n      put file(printfile) skip(spaces);\n   end;\nend copy;"
    }
]